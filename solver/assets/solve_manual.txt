SOLVER MANUAL  

PROLOG  
   This manual is part of the digital-twin-task-scheduler project. See project documentation at: https://github.com/matiasmicheletto/digital-twin-task-scheduler

NAME  
   solve - Computes the optimal allocation of tasks to network nodes

SYNOPSIS  
   solve [OPTIONS] -t [TASK_FILE] -n [NETWORK_FILE] -o [OUTPUT_FORMAT]

DESCRIPTION:  
   This program loads two json files describing a set of precedence related tasks and a network architecture. Tasks have different attributes as computing time, period, deadline, memory requirements, between others and have to be allocated to nodes to their execution. The network on the other side is composed by a set of nodes. There are three types of nodes corresponding to the three network layers: MIST, EDGE and CLOUD. The nodes are connected by links, these last ones have delays indicated in time slots, and it is the time it takes for a task to send its output to its successor if it is allocated in another node. 
   The program computes the optimal allocation of tasks to nodes in order to minimize the total period of the system.  

OPTIONS:  
   -t, --tasks    File with the tasks the instance. Must be in json format.  
   -n, --network  File with the network of the instance. Must be in json format.  
   -c, --config   Optimization parameters.
   -h, --help     (optional) Display this help message.  
   -v, --version  (optional) Displays software version.  
   -s, --solver   (optional) Choose solver. Options are "random", "genetic" or "annealing".
   -o, --output   (optional) Output format. Must be "json", "text" or "csv". Default value is "text".  

EXAMPLE:  
   # Solve instance defined in tasks.json and network.json, with simulated annealing method using configuration declared in config.yaml file and printing output using .json format
   solve -t tasks.json -n network.json -c config.yaml -s annealing -o json

INPUT FILES FORMAT
Schedule file:
   tasks:
   {
      "id": "11ed2bef", // Unique identifier
      "type": "TASK", // For visualization purposes only
      "label": "Task 0", // Label for easy task identifying
      "mist": false, // If this task will be allocated to a mist node, cannot have predecessors
      "C": 1, // Execution time
      "T": 80, // Period
      "D": 80, // Deadline (usually equal to period, but configurable)
      "a": 0, // Activation time
      "M": 1, // Memory requirement
      "successors": [ // List of the IDs of the successor tasks
         "507adb48"
      ],
      "position": { // Used to draw the network.
         "x": 490.86759826529646,
         "y": 365.87258340285246
   }
   precedences:
   {
      "id": "11ed2bef_507adb48", // Unique identifier
      "from": "11ed2bef", // ID of predecessor task
      "to": "507adb48", // ID of succesor task
   }

Network file:
   "nodes":
   {
      "id": "983cb790", // Unique identifier
      "type": "MIST", // Type can be MIST, EDGE or CLOUD
      "label": "Mist 3", // Label for easy node identifying
      "tasks": [], // List of preallocated tasks
      "memory": 5, // Available memory
      "u": 0.7217552226492681, // Maximum utilization factor available
      "links": [ // List of connections to other nodes, reduntant
        {
          "id": "983cb790_b1996e39", // Unique link identifier (usually idFrom_idTo)
          "label": "Mist 3 → Edge 1", // Label for easy link identifying
          "sourceId": "983cb790", // ID of the source node
          "targetId": "b1996e39", // ID of the target node
          "delay": 3, // Delay of the link in time slots
          "bidirectional": false // If data can be sent back and forth or not
        }
      ],
      "position": { // Used to draw the network
        "x": 144,
        "y": 163
      }
   }
   "connections": 
   {
      "id": "9acd628d_af0ac5f7", // Unique identifier
      "label": "Mist 1 → Edge 5", // Label for easy link identifying
      "from": "9acd628d", // ID of the source node
      "to": "af0ac5f7", // ID of the target node
      "delay": 8, // Delay of the link in time slots
      "bidirectional": false // If data can be sent back and forth or not
   }

Optimization parameters file:

tunning: # Weights for different components of the objective function
  alpha: 1 # Weight for finish time sum in objective function
  beta: 1 # Weight for delay cost in objective function
  gamma: 1 # Weight for server usage cost in objective function

simulated_annealing: # SA
  max_init_tries: 5000 # Number of attempts to find a valid initial solution
  max_iterations: 3000 # Total number of iterations
  timeout: 3600 # Timeout in seconds
  stagnation_threshold: 1.0e-6 # Minimum improvement to reset stagnation counter
  stagnation_limit: 200 # Iterations without improvement
  max_neighbor_tries: 30 # Number of neighbor solutions to try at each temperature
  initial_temperature: 150.0 # Starting temperature for annealing (higher = more exploration)
  cooling_rate: 0.995 # Rate at which temperature decreases (closer to 1 = slower cooling)
  min_temperature: 1.0e-3 # Minimum temperature to stop the algorithm
  refinement_priority_method: NORMAL # NORMAL or PSO
  refinement_iterations: 50 # Number of iterations for the refinement phase
  refinement_sigma_max: 0.1 # Initial standard deviation for normal refinement
  refinement_sigma_min: 1.0e-3 # Minimum standard deviation for normal refinement
  refinement_pso_warm_size: 30 # Number of particles in PSO refinement
  refinement_pso_velocity_clamp: 2 # Maximum velocity for particles in PSO refinement
  refinement_pso_inertia_weight: 0.5 # Inertia weight for PSO refinement
  refinement_pso_cognitive_coef: 1.5 # Cognitive coefficient for PSO refinement
  refinement_pso_social_coef: 1.5 # Social coefficient for PSO refinement

random_search: # RS
  max_iterations: 1000 # Total number of iterations
  timeout: 3600 # Timeout in seconds
  stagnation_threshold: 1.0e-6 # Minimum improvement to reset stagnation counter
  stagnation_limit: 200 # Iterations without improvement
  break_on_first_feasible: false # Stop search when first feasible solution is found (used for SA initialization)

genetic_algorithm: # GA
  population_size: 100 # Number of individuals in the population
  max_generations: 800 # Total number of generations
  timeout: 3600 # Timeout in seconds
  elite_count: 5 # Number of top individuals to carry over to the next generation
  stagnation_threshold: 1.0e-6 # Minimum improvement to reset stagnation counter
  stagnation_limit: 200 # Generations without improvement
  mutation_rate: 0.15 # Probability of mutation for each individual
  crossover_rate: 0.75 # Probability of crossover between pairs of individuals

misc: # Miscellaneous settings
  log_file: "solver_log.csv" # File to log solver results


AUTHORS  
   Code was written by Dr. Matias J. Micheletto from IIDEPyS-GSJ (UNPSJB-CONICET) and supervised by Dr. Rodrigo Santos from ICIC (UNS-CONICET).  

REPORTING BUGS  
   Guidelines available at <https://github.com/matiasmicheletto/digital-twin-task-scheduler>.  

COPYRIGHT  
   Copyright   ©   2023   Free   Software   Foundation,  Inc.   License  GPLv3+:  GNU  GPL  version  3  or  later <https://gnu.org/licenses/gpl.html>.  
   This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the  extent  permitted by law.  
