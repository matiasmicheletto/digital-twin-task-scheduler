SOLVER MANUAL  

PROLOG  
   This manual is part of the digital-twin-task-scheduler project. See project documentation at: https://github.com/matiasmicheletto/digital-twin-task-scheduler

NAME  
   solve - Computes the optimal allocation of tasks to network servers.

SYNOPSIS  
   solve [OPTIONS] -t [TASK_FILE] -n [NETWORK_FILE] -o [OUTPUT_FORMAT]
   solve [OPTIONS] -d [DAT_FILE]

DESCRIPTION:  
   This program loads two .json files or a single .dat file describing a set of real-time precedence related tasks and the network architecture. Tasks have different attributes as worse case execution time, period, deadline, memory requirements, between others and have to be allocated to servers in order to compute the optimal schedule. 

   There are three types of servers, also called nodes or processors, corresponding to the three network layers: MIST, EDGE and CLOUD. Some servers can be connected by links, having delays indicated in time slots, representing the time it takes for a task to send its output to its successor, if it is allocated in another server. Servers can redirect data, so the network is fully connected and the delay matrix of nodes have no infinity values.  
   
   The program computes the optimal allocation of tasks to servers in order to minimize three objectives: the sum of all finish slots of all tasks, the total communication delay of the schedule and the cost of servers usage.  

OPTIONS:  
   -t, --tasks    File with the tasks the instance. Must be in json format.  
   -n, --network  File with the network of the instance. Must be in json format.  
   -d, --dat      File with system description using dat format.  
   -c, --config   Optimization parameters (see below).
   -h, --help     (optional) Display this help message.  
   -v, --version  (optional) Displays software version.  
   -s, --solver   (optional) Choose solver. Options are "random", "genetic" or "annealing".
   -o, --output   (optional) Output format. Must be "json", "text", "csv" or "tab". Default value is "text".  
   --set          (optional) Override configuration parameter.  
   --dbg          (optional) Show debugging messages.  

EXAMPLE:  
   # Solve instance defined in tasks.json and network.json, with simulated annealing method using configuration declared in config.yaml file and printing output using .json format
   solve -t tasks.json -n network.json -c config.yaml -s annealing -o json

   # Solve instance defined in instance.dat with random method and saving result in a csv file:
   solve -d instance.dat -s random -o csv > output.csv 

   # Overriding parameters
   solver -t t.json -n n.json -s annealing -o tab \
         --set simulated_annealing.max_iterations=8000 \
         --set tunning.alpha=2 \
         --set genetic_algorithm.population_size=300

INPUT FILES FORMAT
Schedule file:
   tasks:
   {
      "id": "11ed2bef", // Unique identifier
      "type": "TASK", // For visualization purposes only
      "label": "Task 0", // Label for easy task identifying
      "mist": false, // If this task will be allocated to a mist node, cannot have predecessors
      "C": 1, // Execution time
      "T": 80, // Period
      "D": 80, // Deadline (usually equal to period, but configurable)
      "a": 0, // Activation time
      "M": 1, // Memory requirement
      "successors": [ // List of the IDs of the successor tasks
         "507adb48"
      ],
      "position": { // Used to draw the network.
         "x": 490.86759826529646,
         "y": 365.87258340285246
   }
   precedences:
   {
      "id": "11ed2bef_507adb48", // Unique identifier
      "from": "11ed2bef", // ID of predecessor task
      "to": "507adb48", // ID of succesor task
   }

Network file:
   "nodes":
   {
      "id": "983cb790", // Unique identifier
      "type": "MIST", // Type can be MIST, EDGE or CLOUD
      "label": "Mist 3", // Label for easy node identifying
      "tasks": [], // List of preallocated tasks
      "memory": 5, // Available memory
      "u": 0.7217552226492681, // Maximum utilization factor available
      "links": [ // List of connections to other nodes, reduntant
        {
          "id": "983cb790_b1996e39", // Unique link identifier (usually idFrom_idTo)
          "label": "Mist 3 → Edge 1", // Label for easy link identifying
          "sourceId": "983cb790", // ID of the source node
          "targetId": "b1996e39", // ID of the target node
          "delay": 3, // Delay of the link in time slots
          "bidirectional": false // If data can be sent back and forth or not
        }
      ],
      "position": { // Used to draw the network
        "x": 144,
        "y": 163
      }
   }
   "connections": 
   {
      "id": "9acd628d_af0ac5f7", // Unique identifier
      "label": "Mist 1 → Edge 5", // Label for easy link identifying
      "from": "9acd628d", // ID of the source node
      "to": "af0ac5f7", // ID of the target node
      "delay": 8, // Delay of the link in time slots
      "bidirectional": false // If data can be sent back and forth or not
   }

Dat file (values separated by \t): 
N
nodeId (from 1)    memory    u    cost
...
M-1
taskId (from 0)   C    T    D    a    M    allocatedNode
...
P (M x M)
fromTaskId    toTaskId    exists (1/0)
...
S (N x N)
fromNodeId    toNodeId    delay (1000 if not connected)
...


Optimization parameters file:

tunning: # Weights for different components of the objective function
  alpha: 1 # Weight for finish time sum in objective function
  beta: 1 # Weight for delay cost in objective function
  gamma: 1 # Weight for server usage cost in objective function

simulated_annealing: # SA
  max_init_tries: 5000 # Number of attempts to find a valid initial solution
  max_iterations: 3000 # Total number of iterations
  timeout: 3600 # Timeout in seconds
  stagnation_threshold: 1.0e-6 # Minimum improvement to reset stagnation counter
  stagnation_limit: 200 # Iterations without improvement
  max_neighbor_tries: 30 # Number of neighbor solutions to try at each temperature
  initial_temperature: 150.0 # Starting temperature for annealing (higher = more exploration)
  cooling_rate: 0.995 # Rate at which temperature decreases (closer to 1 = slower cooling)
  min_temperature: 1.0e-3 # Minimum temperature to stop the algorithm
  refinement_priority_method: NORMAL # NORMAL or PSO
  refinement_iterations: 50 # Number of iterations for the refinement phase
  refinement_sigma_max: 0.1 # Initial standard deviation for normal refinement
  refinement_sigma_min: 1.0e-3 # Minimum standard deviation for normal refinement
  refinement_pso_warm_size: 30 # Number of particles in PSO refinement
  refinement_pso_velocity_clamp: 2 # Maximum velocity for particles in PSO refinement
  refinement_pso_inertia_weight: 0.5 # Inertia weight for PSO refinement
  refinement_pso_cognitive_coef: 1.5 # Cognitive coefficient for PSO refinement
  refinement_pso_social_coef: 1.5 # Social coefficient for PSO refinement

random_search: # RS
  max_iterations: 1000 # Total number of iterations
  timeout: 3600 # Timeout in seconds
  stagnation_threshold: 1.0e-6 # Minimum improvement to reset stagnation counter
  stagnation_limit: 200 # Iterations without improvement
  break_on_first_feasible: false # Stop search when first feasible solution is found (used for SA initialization)

genetic_algorithm: # GA
  max_init_tries: 5000 # Number of attempts to find a valid initial solution
  population_size: 100 # Number of individuals in the population
  max_generations: 800 # Total number of generations
  timeout: 3600 # Timeout in seconds
  elite_count: 5 # Number of top individuals to carry over to the next generation
  stagnation_threshold: 1.0e-6 # Minimum improvement to reset stagnation counter
  stagnation_limit: 200 # Generations without improvement
  mutation_rate: 0.15 # Probability of mutation for each individual
  crossover_rate: 0.75 # Probability of crossover between pairs of individuals

misc: # Miscellaneous settings
  log_file: solver_log.csv # File to log solver results


AUTHORS  
   Code was written by Dr. Matias J. Micheletto from IIDEPyS-GSJ (UNPSJB-CONICET) and supervised by Dr. Rodrigo Santos from ICIC (UNS-CONICET).  

REPORTING BUGS  
   Guidelines available at <https://github.com/matiasmicheletto/digital-twin-task-scheduler>.  

COPYRIGHT  
   Copyright   ©   2023   Free   Software   Foundation,  Inc.   License  GPLv3+:  GNU  GPL  version  3  or  later <https://gnu.org/licenses/gpl.html>.  
   This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the  extent  permitted by law.  
